
let a = "string";

let b:string = "문자열입니다."; // 변수명:타입 이러한 형식으로 할당해야합니다.

let num:number = 1000;

let bool:boolean = true;

// undefinde, null도 변수명:타입 으로 할당할 수 있지만 고정으로 사용하지 않고
// object도 타입 할당 가능. 하지만 특정 대상을 가르키지 못해 안정성 보장 X, 때문에 사용 권장하지 않음. 차라리 각자 마다 타입을 지정하는게 좋음.

const numArr:number[] = [1, 2, 3]; // 배열서 사용시 변수명:타입[] 로 할당 가능하다.
const mixedArr: (string | number)[] = [1, "가", 2]; // 배열서 사용시 변수명:타입( | )[] 로 할당이 가능하며 여러개의 타입을 넣어줄 수 있다 `Union Type`이라고 불린다.

let tuple: [number, string, string]; // 튜플이라고 합니다. 길이와 각 요소마다 타입이 정해진 배열을 뜻합니다. 길이는 3이고 숫자, 문자열, 문자열만 넣을 수 있고 다른 타입은 오면 안된다라는 조건입니다.

// 타입을 명시하지 않았을 때
let num1 = 1 // 일반적으로 적합한 타입을 넣어줍니다. 이것을 **타입 추론**이라고 합니다.

// 앞서 타입 종류를 배울 때 변수를 let 변수명:타입 = 값 과 같은 형태로 선언했습니다.
// 하지만 값만 넣어도 이미 타입스크립트에서 타입을 추론하기 때문에
// string이라는 타입추론 + string 이라는 타입 명시를 하는 것은 중복적으로 타입을 명시한 것으로 볼 수 있습니다. 
// 따라서 타입이 변하지 않는(하나의 타입만 갖는) 변수에는 따로 타입을 적지 않는 것을 선호하는 경우가 많습니다.

// any
let value; // 변수를 초기화하지 않고 생성만 했을 때는 타입이 any로 나옵니다. any를 권장하지 않는 이유는 어떤 타입이든 들어갈 수 있는 형태로 만들면 JS를 쓰는것과 TS쓰는 것과 차이가 없어서 권장하지 않습니다. 
// any타입은 타입스크립트에서 특정 값으로 인해 유형 검사 오류가 발생하는 것을 막기 위해 사용할 수 있습니다. 

// 유니온타입 -> 변수명:타입 | 다른타입
let union:string|number
union=1 //이렇게하면 number가됨
union="hello"//이렇게하면 string이됨


