// 리액트 훅
// 16.8버전에 도입이 된 기술이며 클래스 컴포넌트에서 사용하던 상태관리, 라이프사이클 기능 등을 함수형 컴포넌트에서 사용이 가능하게 되었습니다.

// 클래스, 함수 컴포넌트 차이점
// 클래스는 라이프사이클 및 state 사용가능
// 함수 클래스 컴포넌트보다 간편하게 사용이 가능하다. hook을 사용하여 클래스에서 사용하던 라이프사이클 및 state를 사용 할 수 있게 되었다.

// 클래스 컴포넌트 문제점
// 유지보수가 어려우며 this동작이 다양하여 오류가 발생 할 수 있다. 코드의 복잡성이 높다

// 함수사용 못한 이유 - hooks나오기 전에 상태를 가지지 못해서 클래스 컴포넌트를 사용했음

// 함수가 상태를 가지지 못하는 이유 
// 함수형은 리렌더링 진행 시, 함수 안에있는 코드가 다시 실행이 됨. - state를 관리 할 수 없음.

// hooks - useState
// useState로 state관리를 진행 할 수 있다.

// 라이프사이클
// class - this.state, this.setState / 함수형 - mount, update, unmount

// mount - 컴포넌트가 생성되고 렌더링을 거치는 단계  -> 컴포넌트가 생성될 때 한 번만 호출되는 단계
// update - props, state값이 변경될 때 리렌더링 하는 단계 -> props, state값이 변경될 때 이루어지는 단계
// unmount - 컴포넌트가 종료되는 과정 -> 컴포넌트가 소멸될 때 호출됩니다.

// 라이프사이클을 사용할 수 있게 도와주는 건 -> useEffect

// useState는 state상태관리를 해준다. useEffect는 클래스 컴포넌트서 사용하던 라이프사이클을 사용할 수 있게 도와준다.

// useEffect를 사용시에 안에 있는 state나 props가 있다면 dependency(의존성배열)에 값을 넣어줘야한다.
// 의존성배열에 값을 넣지 않으면 useEffect에 등록한 함수가 실행될 때 최신 props나 state를 가르키지 않는다.
// 또한 의존성배열을 생략시 컴포넌트가 리렌더링 될 때마다 호출이 된다.

// state, props 의미
// state는 컴포넌트에서 사용하고 관리 할 수 있는 상태값, props는 부모컴포넌트서 자식컴포넌트로 상속되는 읽기 전송 데이터. 

// 내가 사용하거나 사용해본 react hooks
// useState - 컴포넌트 state(상태값)관리
// useEffect - 컴포넌트가 렌더링 될 때마다 특정 작업을 실행 가능. 클래스 컴포넌트서 사용하던 라이프사이클을 사용 할 수 있게 해줌.
// useContext - 전역에서 사용할 수 있는 context를 가져오는 hook 
// useReducer - 여러 개의 상태 관리를 할 때 사용하며, 컴포넌트의 상태 업데이트 로직을 컴포넌트에서 분리 시킬수 있는 hook 
// useRef - ref객체를 생성하고, 특정 DOM에 접근하여 DOM조작을 가능하게 하는 hook이다.
// useMemo - 메모이제이션 된 값을 반환하는 함수, 동일한 계산을 반복해야 할 때 이전 계산된 값을 메모리에 저장하여 동일한 계산 반복 수행을 제거함
// useCallback - 함수를 재사용 합니다. 값이 변경이 되면 새로운 함수를 return 값이 변경되지 않는다면 기존 함수를 return

// React.memo - 전달 받은 props의 값을 이전 값과 비교하여 리렌더링을 진행함.